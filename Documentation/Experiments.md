What They Do, and How to Run the Experiments 
=============================================

General Instructions
---------------------

The command for running all the experiments always includes the -G option. 
This runs TruffleMate in interpreted mode. We strongly recommend to run the experiments with just in time compilation enabled. 
To do so, TruffleMate requires the installation of the [Graal compiler](http://www.oracle.com/technetwork/oracle-labs/program-languages/overview/index-2301583.html). We suggest to download the last binaries from the official oracle site and then configure TruffleMate's [executable script](https://github.com/charig/TruffleMATE/blob/papers/TSE2017/som) so that it points to the right binary. 
Then just remove the -G option from every command.

Benchmarks are run by a harness. The harness takes three parameters: benchmark name, number of iterations, and problem size. 
The benchmark name corresponds to a class or file of a benchmark. The number of iterations defines how often a benchmark should be executed. 
The problem size can be used to influence how long a benchmark takes. 
Note that the benchmarks just output the time it takes for the machine to run them. 
However, each benchmark verifies the result (see the method *verifyResult*) and throws an error in case the results is different from the expected one.    

Ephemeral Variability 
---------------------
The experiment is described in the paper in the motivation example (Sections 3.1) while the results are presented in 
Section 5.1.

The [folder](https://github.com/charig/SOM/blob/papers/ICOOOLPS17/Examples/Benchmarks/InstanceMigration/) contains all 
the benchmarks and any neccesary additional file. 

The base class describing the experiment is [RawAccumulator](https://github.com/charig/SOM/blob/papers/ICOOOLPS17/Examples/Benchmarks/Mate/InstanceMigration/RawAccumulator.som).
This class runs the baseline: just walking through an array of point instance and gather their x field.
[EphemeralInstanceMigration](https://github.com/charig/SOM/blob/papers/ICOOOLPS17/Examples/Benchmarks/Mate/InstanceMigration/EphemeralInstanceMigration.som) 
add to basic things to the baseline behavior.
1) After running the first iteration it change the shape of one of the object of the array.
2) After running the second iteration it restores the original shape to the corresponding instance.
This two things conforms a simple way of simulating the proxy initialization behavior described in the paper.
[EphemeralInstanceMigrationUpdateDC](https://github.com/charig/SOM/blob/papers/ICOOOLPS17/Examples/Benchmarks/Mate/InstanceMigration/EphemeralInstanceMigrationUpdateDC.som) and 
[EphemeralInstanceMigrationResetDC](https://github.com/charig/SOM/blob/papers/ICOOOLPS17/Examples/Benchmarks/Mate/InstanceMigration/EphemeralInstanceMigrationResetDC.som) 
use the MOP to clean the pollution in the dispatch chains generated by the ephemeral variability behavior of the EphemeralInstanceMigration bench.

Finally, the experiment runs with:
      
      ./som -G --mate -activateMate -cp Smalltalk:Smalltalk/Mate/:Smalltalk/Mate/MOP:Smalltalk/Mate/Compiler:Examples/Benchmarks:Examples/Benchmarks/Mate/InstanceMigration: BenchmarkHarness RawAccumulator 1 2 1
      
Changing *RawAccumulator* for *EphemeralInstanceMigration* or *EphemeralInstanceMigrationUpdateDC* or 
*EphemeralInstanceMigrationResetDC* runs the experiment with the aforementioned alternatives.       


Highly Indirect Variability
---------------------------
The experiment is described in the paper in Section 5.2.

The [folder](https://github.com/charig/SOM/blob/papers/ICOOOLPS17/Examples/Benchmarks/Mate/Splitting/) contains the benchmarking files.

This experiment mainly exploits the compiler reflective capabilities to split the target of a call-site, 
not automatically splitted because of the highly indirect variability phenomenon, manually.

The baseline exhibiting the aforementioned phenomenon is [BasicToDo](https://github.com/charig/SOM/blob/papers/ICOOOLPS17/Examples/Benchmarks/Mate/Splitting/BasicToDo.som) 
while [BasicToDoSplit](https://github.com/charig/SOM/blob/papers/ICOOOLPS17/Examples/Benchmarks/Mate/Splitting/BasicToDoSplit.som) 
force the splitting using the MOP.

To run the experiment:

      ./som -G --mate -activateMate -cp Smalltalk:Smalltalk/Mate/:Smalltalk/Mate/MOP:Smalltalk/Mate/Compiler:Examples/Benchmarks:Examples/Benchmarks/Mate/InstanceMigration:Examples/Benchmarks/Mate/Splitting BenchmarkHarness BasicToDo 1 2 1

Note that the benchmark performing the splitting only works in compilation mode.

Using the Full Benchmark Setup
---------------------------

The data for the paper is automatically generated by a ReBench run of the previous benchmarks a predefined number of iterations.

ReBench can be installed via the Python package manager pip:

      pip install ReBench

The benchmarks can be executed with the following command in the root folder:

      rebench -d --without-nice core-lib/mate.conf ReflectiveCompilation

The -d gives more output during execution, and --without-nice means that the nice tool enforcing high process priority is not used. We don't use it here to avoid requiring root rights.
